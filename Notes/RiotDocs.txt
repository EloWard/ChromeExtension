League of Legends
5 hours ago Updated
Developer API Policy
Before you begin, read through the General and Game Policies, Terms of Use and Legal Notices. Developers must adhere to policy changes as they arise.

Registration
If your product serves players, you must register it with us regardless of whether or not your product uses official documented APIs. You must make sure its description and metadata are kept up to date with the current version of your product.

Monetization
Your product cannot feature betting or gambling functionality.
You may monetize your product as long as your product is registered on the Developer Portal and your product status is either Approved or Acknowledged.
You must have a free tier of access for players, which may include advertising
Your content must be transformative if you are charging players for it
What is transformative?
Was value added to the original by creating new information, new aesthetics, new insights, and understandings? If so, then it was transformative.
Acceptable ways to charge players are:
Subscriptions, donations, or crowdfunding
Entry fees for tournaments
Currencies that cannot be exchanged back into fiat
Your monetization cannot gouge players or be unfair (yes, we get to decide that)
If you are unsure if your monetization platform is acceptable, contact us through the Developer Portal
Game Integrity
Products must not use or incorporate information not present in the game client that would give players a competitive edge (e.g., automatically or manually allowing tracking enemy ultimate cooldowns), especially when such data is not already accessible through regular gameplay.
Products cannot alter the goal of the game (i.e. Destroy the Nexus).
Products cannot create an unfair advantage for plaeyers, like a cheating program or giving some players an advantage that others would not otherwise have.
Products should increase, and not decrease the diversity of game decisions (builds, compositions, characters, decks).
Products should not remove game decisions, but may highlight decisions that are important and give multiple choices to help players make good decisions.
Products cannot create alternatives for official skill ranking systems such as the ranked ladder. Prohibited alternatives include MMR or ELO calculators. Leaderboards or rankings based off of a third party platform's community tournaments or challenges that would not reasonably be interpreted as official are allowed.
Products cannot de-anonymize players who cannot reasonably be identified from visible information.
Products may not expose a player's historic Riot IDs
Tournament Policies
Tournaments must
Follow all monetization policies above
Allot at least 70% of the entry fees to the prize pool
Win conditions must be fair and transparent to players (we determine fair)
Not include any gambling
If you are a tournament organizer operating in the US or Canada, please refer to, and adhere to, these North American tournament organizer policies.
If you are a tournament organizer operating in Europe, please refer to, and adhere to, these European tournament organizer policies.
 

Summoner Names to Riot IDs
On November 20, 2023, we are transitioning our systems away from Summoner Names to using Riot ID as an authoritative way to reference players in League and TFT starting later this year. As such, you will need to make an update to the applicable API. Details for this transition can be found below.

All player-facing front-end fields and forms will require modification. Applications featuring the "Find your Summoner by Region + Name" functionality must adapt to locate summoners using Riot IDs, which are formed by combining the "game name" and "tag line".

For all other Riot API endpoints, filtering by player can be accomplished using either the PUUID or summonerID. Some APIs offer both options, but we recommend employing PUUID endpoints when available.

We recommend no longer using these endpoints (deprecated):

https://developer.riotgames.com/apis#summoner-v4/GET_getBySummonerName - /lol/summoner/v4/summoners/by-name/{summonerName}
https://developer.riotgames.com/apis#tft-summoner-v1/GET_getBySummonerName - /tft/summoner/v1/summoners/by-name/{summonerName}
Although deprecated, they can still be used to convert Summoner Names to PUUID or summonerID. However, we discourage using them as part of your application since they will be removed in the future.

Obtaining PUUID and summonerID from RiotID
(ACCOUNT-V1) https://developer.riotgames.com/apis#account-v1/GET_getByRiotId - Utilize the endpoint /riot/account/v1/accounts/by-riot-id/{gameName}/{tagLine} to obtain the PUUID associated with a given account by Riot ID (gameName + tagLine).
(SUMMONER-V4) https://developer.riotgames.com/apis#summoner-v4/GET_getByPUUID - Access the endpoint /lol/summoner/v4/summoners/by-puuid/{encryptedPUUID} to retrieve summoner data by PUUID, including summonerID.
Obtaining Riot ID from PUUID
For third-party apps, displaying Riot IDs in place of summoner names within frontend fields is now necessary. If you lack a Riot ID for a particular player in your database or wish to keep it up to date, you can acquire it through the following endpoints:

(ACCOUNT-V1) https://developer.riotgames.com/apis#account-v1/GET_getByPuuid - Use the endpoint /riot/account/v1/accounts/by-puuid/{puuid} to fetch account information (gameName + tagLine) by PUUID.
Obtaining Riot ID from summonerID
In cases where you do not possess a PUUID for a player, you can employ the player's summonerID to obtain the PUUID:

(SUMMONER-V4) https://developer.riotgames.com/apis#summoner-v4/GET_getBySummonerId - Access the endpoint /lol/summoner/v4/summoners/{encryptedSummonerId} to retrieve summoner data by summonerID, which can be used to obtain the corresponding PUUID.
Summoner Names Post Migration
Following this migration, Summoner Names endpoints will remain accessible. However, they will no longer be player-facing. We intend to keep them temporarily to avoid disrupting existing APIs. For summoners created after this transition, they will be assigned a random uuidv4 generated string.

We strongly advise utilizing this deprecation period to refactor your existing applications and remove reliance on the summoner names field. In future releases, we will remove summoner names from the API altogether.

Example of a RiotID input:RiotID Input

Check our FAQ for more details!

Game Policy
Use Cases for Production Keys
Production keys are meant for larger-size, professional projects.

Riot analyzes two main factors when evaluating applications:

Is the use case good and approved?
Does the developer show they will deliver on that use case?
To demonstrate that your app meets the use case, you should be able to have one or more of the following:

Be an established brand that wants to add Riot Games to its portfolio.
New app that is fully functional and testable by Riot.
Prototype that is mostly testable by Riot.
Mockups where Riot can clearly express your intent and the user flow.
A deck that shows your ambition and intent and some of the user flow.
Riot needs to see the user flow to understand what your intended player experience is, such as account creation process, login pipeline, or queuing up for match pipeline.

You must also send a link to a working site, mockup, prototype, or rendering where it is easy to understand the user flows of the tool.

Examples of Approved Use Cases for Personal Keys
Personal keys are meant for smaller-size, personal projects.

Personal sites.
School projects.
Creating a proof of concept for a Production Key request
Examples of Approved Use Cases for Production Keys.
Showing (self) player stats
Running tournaments.
Training tools that allow players to view their own match histories and aggregate stats.
Looking For Game (LFG) tools.
Game overlays that provide static data that is available prior to the game.
Aggregate player stats (no specific players).
Official Ladder Leaderboards.
Examples of Unapproved Use Cases
The following use cases will not be approved:

Products cannot display win rates for Augments or Arena Mode items. This applies to all websites, applications and overlays.
Products may not provide any game-session-specific information that would be previously unknown to the player.
Apps that dictate player decisions.
Apps that violate the general game policies.
Products may not publicly display a player's match history from the custom match queue unless the player opts in to share this specifically for League of Legends. Otherwise, a player’s custom match data may only be made available to them using RSO.
RSO Integration
RSO or Riot Sign On, allows players to safely link their Riot Account to other applications. This access is only available to developers with Production Level API Keys.

Getting a Production Key
Before you can get started with RSO, you will need a production key. If you do not have one, please create one at https://developer.riotgames.com after reading our policies. If approved, we will contact you in the developer portal app messaging to kick off the RSO integration process.

Implementing RSO
RSO - Client Secret Basic - Private Key JWT

Sample RSO Node App: https://static.developer.riotgames.com/docs/rso/rso-example-app.zip

Players should be directed to login at this link: https://auth.riotgames.com/authorize?client_id={your-client-id}&redirect_uri={your-redirect-uri}&response_type=code&scope=openid+offline_access.

After logging in, players are redirected back to the redirect_uri you specified. See Implementing Riot Sign On and Example RSO Node App for information about how to integrate with RSO and to view a sample Node web server that implements the example.

Your RSO client has access to endpoints that will allow you to identify who logged in.

For Legends of Legends, you will use /riot/account/v1/accounts/me:

curl --location --request GET 'https://americas.api.riotgames.com/riot/account/v1/accounts/me' --header 'Authorization: Bearer {accessToken}'
curl --location --request GET 'https://europe.api.riotgames.com/riot/account/v1/accounts/me' --header 'Authorization: Bearer {accessToken}' 
curl --location --request GET 'https://asia.api.riotgames.com/riot/account/v1/accounts/me' --header 'Authorization: Bearer {accessToken}' 
The accounts data return from each cluster is identical. We recommend using the cluster closest to your servers.

Routing Values
To execute a request to the League of Legends (LoL) API, you must select the correct host to execute your request to. LoL API uses routing values in the domain to ensure your request is properly routed. Platform IDs and regions as routing values, such as na1 and americas. Routing values are determined by the topology of the underlying services. Services are frequently clustered by platform resulting in platform IDs being used as routing values. Services may also be clustered by region, which is when regional routing values are used. The best way to tell if an endpoint uses a platform or a region as a routing value is to execute a sample request through the Reference page.

TH2 and PH2 servers have been merged into the SG2 server. This server merge is part of our ongoing effort to enhance the gaming experience for Teamfight Tactics (TFT) and League of Legends (LoL) players in Southeast Asia (SEA).

Platform Routing Values
PLATFORM	HOST
BR1	br1.api.riotgames.com
EUN1	eun1.api.riotgames.com
EUW1	euw1.api.riotgames.com
JP1	jp1.api.riotgames.com
KR	kr.api.riotgames.com
LA1	la1.api.riotgames.com
LA2	la2.api.riotgames.com
NA1	na1.api.riotgames.com
OC1	oc1.api.riotgames.com
TR1	tr1.api.riotgames.com
RU	ru.api.riotgames.com
SG2	sg2.api.riotgames.com
TW2	tw2.api.riotgames.com
VN2	vn2.api.riotgames.com
Regional Routing Values
REGION	HOST
AMERICAS	americas.api.riotgames.com
ASIA	asia.api.riotgames.com
EUROPE	europe.api.riotgames.com
SEA	sea.api.riotgames.com
Data Dragon
Data Dragon is our way of centralizing League of Legends game data and assets, including champions, items, runes, summoner spells, and profile icons. All of which can be used by third-party developers. You can download a compressed tarball (.tgz) for each patch that contains all assets for that patch. Updating Data Dragon after each League of Legends patch is a manual process, so it is not always updated immediately after a patch.

Latest
https://ddragon.leagueoflegends.com/cdn/dragontail-13.22.1.tgz

Patch 10.10 was uploaded as a zip archive (.zip) instead of the typical compressed tarball (.tgz)
https://ddragon.leagueoflegends.com/cdn/dragontail-10.10.5.zip

Versions
You can find all valid Data Dragon versions in the versions file. Typically there is only a single build of Data Dragon for a given patch, however, there may be additional builds. This typically occurs when there is an error in the original build. As such, you should always use the most recent Data Dragon version for a given patch for the best results.

https://ddragon.leagueoflegends.com/api/versions.json

Regions
Data Dragon versions are not always equivalent to the League of Legends client version in a region. You can find the version each region is using in the realms files.

https://ddragon.leagueoflegends.com/realms/na.json

Data & Assets
Data Dragon provides two kinds of static data: data files and game assets. The data files provide raw static data on various components of the game such as summoner spells, champions, and items. The assets are images of the components described in the data files.

Data Files
The data file URLs include both a version and language code. The examples in the documentation below use version 13.22.1 and the en_US language code. If you want to view assets released in other versions or languages, replace the version or language code in the URL.

Languages
Data Dragon provides localized versions of each of the data files in languages supported by the client. Below is a list of the languages supported by Data Dragon, which you can also retrieve from the Data Dragon languages file.

https://ddragon.leagueoflegends.com/cdn/languages.json

CODE	LANGUAGE
cs_CZ	Czech (Czech Republic)
el_GR	Greek (Greece)
pl_PL	Polish (Poland)
ro_RO	Romanian (Romania)
hu_HU	Hungarian (Hungary)
en_GB	English (United Kingdom)
de_DE	German (Germany)
es_ES	Spanish (Spain)
it_IT	Italian (Italy)
fr_FR	French (France)
ja_JP	Japanese (Japan)
ko_KR	Korean (Korea)
es_MX	Spanish (Mexico)
es_AR	Spanish (Argentina)
pt_BR	Portuguese (Brazil)
en_US	English (United States)
en_AU	English (Australia)
ru_RU	Russian (Russia)
tr_TR	Turkish (Turkey)
ms_MY	Malay (Malaysia)
en_PH	English (Republic of the Philippines)
en_SG	English (Singapore)
th_TH	Thai (Thailand)
vi_VN	Vietnamese (Viet Nam)
id_ID	Indonesian (Indonesia)
zh_MY	Chinese (Malaysia)
zh_CN	Chinese (China)
zh_TW	Chinese (Taiwan)
Champions
There are two kinds of data files for champions. The champion.json data file returns a list of champions with a brief summary. The individual champion JSON files contain additional data for each champion.

https://ddragon.leagueoflegends.com/cdn/13.22.1/data/en_US/champion.json
https://ddragon.leagueoflegends.com/cdn/13.22.1/data/en_US/champion/Aatrox.json

Interpreting Spell Text
Lore, tips, stats, spells, and even recommended items are all part of the data available for every champion. Champion spell tooltips often have placeholders for variables that are signified by double curly brackets. Here are some tips about interpreting these placeholders:

{{ eN }} placeholders
Placeholders are replaced by the corresponding item in the array given in the effectBurn field. For example, {{ eN }} is a placeholder for spell["effectBurn"]["1"].

/* Amumu's Bandage Toss */
"tooltip": "Launches a bandage in a direction. If it hits an enemy unit, Amumu pulls himself to them, dealing {{ e1 }} <scaleAP>(+{{ a1 }})</scaleAP> magic damage and stunning for {{ e2 }} second.",
"effectBurn": [
  null,
  "80/130/180/230/280",
  "1",
  "1350",
  ...
]
{{ aN }} or {{ fN }} placeholders
These placeholders are slightly more complicated. Their values can be found in the vars field. First, find the object in the vars array whose key matches the variable. For example, for {{ a1 }}, find the object in the vars array whose key field has the value a1. The value for this variable is the coeff field in that same object.

/* Amumu's Bandage Toss */
"tooltip": "Launches a bandage in a direction. If it hits an enemy unit, Amumu pulls himself to them, dealing {{ e1 }} <scaleAP>(+{{ a1 }})</scaleAP> magic damage and stunning for {{ e2 }} second.",
"vars": [
  {
    "key": "a1",
    "link": "spelldamage",
    "coeff": [
      0.7
    ]
  }
]
Under a champions spells there are two fields effect and effectBurn. effect contains an array of an ability's values per level where, in contrast, effectBurn contains a string of all the values at every level. (e.g., "effect": [30,60,90,120,150] vs "effectBurn": "30/60/90/120/150"). You might notice how the effect and effectBurn arrays have a null value in the 0 index. This is because those values are taken from designer-facing files where arrays are 1-based. JSON is 0-based so a null is inserted to make it easier to verify the JSON files are correct.

"effect": [
  null,
  [ 120, 150, 180, 210, 240 ],
  [ 50, 70, 90, 110, 130 ],
  [ 25, 35, 45, 55, 65 ],
  [ 0.2, 0.2, 0.2, 0.2, 0.2 ],
  [ 50, 60, 70, 80, 90 ]
],
"effectBurn": [
  "",
  "120/150/180/210/240",
  "50/70/90/110/130",
  "25/35/45/55/65",
  "0.2",
  "50/60/70/80/90"
]
Calculating Spell Costs
In most cases a spell costs mana or energy, you will find those related costs under the cost and costBurn fields. When a spell costs health, the cost will be found in the effect and effectBurn fields. You can determine how to calculate the cost of a spell by looking at the resource field, which should point you to the variable being used to display the cost of a spell.

/* Soraka's Astral Infusion */
"resource": "10% Max Health, {{ cost }} Mana",
"cost": [ 20, 25, 30, 35, 40 ],
"costBurn": "20/25/30/35/40"
/* Shen's Vorpal Blade */
"resource": "{{ cost }} Energy",
"cost": [ 60, 60, 60, 60, 60 ],
"costBurn": "60"
/* Dr. Mundo's Infected Cleaver */
"resource": "{{ e3 }} Health",
"cost": [ 0, 0, 0, 0, 0 ],
"costBurn": "0",
"effect": [
  null,
  [ 80, 130, 180, 230, 280 ],
  [ 15, 18, 21, 23, 25 ],
  [ 50, 60, 70, 80, 90 ],
  [ 40, 40, 40, 40, 40 ],
  [ 2, 2, 2, 2, 2 ]
],
"effectBurn": [
  "",
  "80/130/180/230/280",
  "15/18/21/23/25",
  "50/60/70/80/90",
  "40",
  "2"
]
Champion Splash Assets
https://ddragon.leagueoflegends.com/cdn/img/champion/splash/Aatrox_0.jpg

The number at the end of the filename corresponds to the skin number. You can find the skin number for each skin in the file for each individual champion in Data Dragon. Each champion contains a skins field and the skin number is indicated by the num field.

/* Aatrox (id: 266) */
"skins": [
  {
    "id": 266000,
    "name": "default",
    "num": 0
  },
  {
    "id": 266001,
    "name": "Justicar Aatrox",
    "num": 1
  },
  {
    "id": 266002,
    "name": "Mecha Aatrox",
    "num": 2
  }
]
Champion Loading Screen Assets
https://ddragon.leagueoflegends.com/cdn/img/champion/loading/Aatrox_0.jpg
The number at the end of the filename follows the same convention described in the Champion Splash Art.

Champion Square Assets
https://ddragon.leagueoflegends.com/cdn/13.22.1/img/champion/Aatrox.png

Champion Passive Assets
https://ddragon.leagueoflegends.com/cdn/13.22.1/img/passive/Anivia_P.png

You can find the filename for each champion's passive in the individual champion Data Dragon file. The JSON contains a passive field with image data. The filename is indicated by the full field.

/* Anivia (id: 34) */
"passive": {
  "name": "Rebirth",
  "description": "Upon dying, Anivia will revert into an egg. If the egg can survive for six seconds, she is gloriously reborn.",
  "image": {
    "full": "Anivia_P.png",
    "sprite": "passive0.png",
    "group": "passive",
    "x": 240,
    "y": 0,
    "w": 48,
    "h": 48
    }
  }
} 
Champion Ability Assets
https://ddragon.leagueoflegends.com/cdn/13.22.1/img/spell/FlashFrost.png

You can find the file name for each champion's abilities in the individual champion Data Dragon file. The spells field contains an array of objects which includes image data. The filename is indicated by the full field.

/* Anivia (id: 34) */
"spells": [
  {
    "id": "FlashFrost",
    "name": "Flash Frost",
    "description": "Anivia brings her wings together and summons a sphere of ice that flies towards her opponents, chilling and damaging anyone in its path. When the sphere explodes it does moderate damage in a radius, stunning anyone in the area.",
    "image": {
      "full": "FlashFrost.png",
      "sprite": "spell0.png",
      "group": "spell",
      "x": 192,
      "y": 144,
      "w": 48,
      "h": 48
    }
  },
  ...
]
Items
Data Dragon also provides the same level of detail for every item in the game. Within Data Dragon, you can find info such as the item's description, purchase value, sell value, items it builds from, items it builds into, and stats granted from the item.

https://ddragon.leagueoflegends.com/cdn/13.22.1/data/en_US/item.json

The effect field holds an array of variables used extra scripts. For example, on Doran's shield you see the following data in the effect field, which corresponds to the 8 damage that is blocked from champion attacks.

"effect": {
  "Effect1Amount": "8"
}
Stat Naming Conventions
A list of possible stats that you gain from items, runes, or masteries can also be found in Data Dragon. You can find a list of stats gained by the item, rune, or mastery by searching for the stats field. Below are some tips when it comes to understanding what a stat means and how they are calculated:

Mod stands for modifier.
An "r" at the beginning of the stat means those stats can be found on runes.
Displaying flat vs. percentage vs. per 5 etc. is case-by-case. it will always be the same for a given stat. For example, PercentAttackSpeedMod will always be multiplied by 100 and displayed it as a percentage.
Stats are called flat if you add them together, and percent if you multiply them together.
Tenacity from an item does NOT stack but tenacity from a rune DOES stack.
Item Assets
https://ddragon.leagueoflegends.com/cdn/13.22.1/img/item/1001.png
The number appended to the item filename corresponds to the item id. You can find a list of the items ids in the item data file.

Other
Summoner Spells
https://ddragon.leagueoflegends.com/cdn/13.22.1/data/en_US/summoner.json
https://ddragon.leagueoflegends.com/cdn/13.22.1/img/spell/SummonerFlash.png

Profile Icons
https://ddragon.leagueoflegends.com/cdn/13.22.1/data/en_US/profileicon.json
https://ddragon.leagueoflegends.com/cdn/13.22.1/img/profileicon/685.png

Minimaps
https://ddragon.leagueoflegends.com/cdn/6.8.1/img/map/map11.png
The number appended to the map filename corresponds to the map id. You can find a list of the map ids in the Map Names section of Game Constants.

Sprites
https://ddragon.leagueoflegends.com/cdn/13.22.1/img/sprite/spell0.png

Scoreboard Icons (version 5.5.1)
https://ddragon.leagueoflegends.com/cdn/5.5.1/img/ui/champion.png
https://ddragon.leagueoflegends.com/cdn/5.5.1/img/ui/items.png
https://ddragon.leagueoflegends.com/cdn/5.5.1/img/ui/minion.png
https://ddragon.leagueoflegends.com/cdn/5.5.1/img/ui/score.png
https://ddragon.leagueoflegends.com/cdn/5.5.1/img/ui/spells.png

Tournament API
League of Legends leverages custom game lobbies to support developers that want to build Tournaments for players. Custom games can use Tournament Code that help you quickly and easily get players into private custom game lobbies with preset game settings, such as map and pick type. At the completion of each Tournament Code enabled game, the results will be forwarded automatically (HTTP POST) to a URL specified by the tournament developer.



The Tournaments API allows you to:

Register tournament providers and tournaments in a specific region/shard and its callback URL.
Generate tournament codes for a given tournament.
Receive game results in the form of an automatic callback (HTTP POST) from League of Legends servers whenever a game created using tournament code has been completed.
Use match identifier (matchID) received in the callback to pull full stats data for the given match.
Pull end of game data based on given tournament code in case the callback is never received.
Query pre-game lobby player activity events for a given tournament code.
Best Practices
To preserve the quality of the tournaments service, your Tournaments API Key may be revoked if you do not adhere to the following best practices:

Respect the rate limit for your Tournament API Key and implement logic that considers the headers returned from a 429 Rate Limit Exceeded response.
Implement logic to detect unsuccessful API calls and back off accordingly. Please notify us if you believe your application is working correctly and you are receiving errors, but do not continue to slam the tournaments service with repeatedly unsuccessful calls.
Generate tournaments and tournament codes only as needed in production and development. Please don't create 1,000 tournament codes for a 10 game tournament. As a reminder, you can always create additional tournament codes as your tournament grows.
Tournaments and tournament codes should be generated within a reasonable time in relation to the event. Do not pre-create tournaments and tournament codes at the start of the year and use them as the year progresses, but rather generate the tournament and codes as the event is announced and participants sign up.
Tournament API Notes
When working with the Tournament API, keep the following in mind:

Tournament providers are strongly associated with API keys, regenerating an API key will require a new provider.
Though tournament codes can be re-used to generate additional lobbies. For best results with callbacks and Match-v4 lookups, create a single match with a tournament code.
Lobby events should only be used to audit Tournament matches as needed. In rare cases lobby events may get dropped. Using lobby events to programmatically progress a tournament or to forfeit participants is not advised.
Tournaments will expire if there are no active codes associated with the tournament. Tournament codes are eligible for expiration three months after they are generated. As tournaments and their codes can expire, creating them as close to the event as possible ensures no disruptions. For the best results:
Create a tournament no more than a week before the start of the first match.
Upon creation of the tournament, generate a code to ensure the tournament has an active tournament code associated with it (thereby making ineligible for cleanup).
Tournament codes should be generated as needed, not all at once at the start of the event.
Use Case Example
Presume there is a tournament website created for League of Legends players that does the following:

Announces tournament and rules
Registers players/teams
Generates/renders tournament brackets
Seeds registered teams across the brackets
Sends invites for matched teams to play their games
Collects end of game results from team captains
Provides new matches for teams that advance
Officiates for situations when something goes wrong (no show, etc)
The Tournaments API is designed to help automate the last four mentioned functions of tournament websites.

It is recommended to register a tournament provider (specifying region/shard and URL for results) well in advance and do a full loop testing to ensure everything is setup properly for your web service.

Tournaments API Structure
The Tournaments API introduces a simple parent-child data structure to ensure data model consistency:



Tournaments API Methods
Access to the Tournaments API provides several new methods that can be viewed on the API Reference page. You should explore every method to get more information on actual usage including the format and description of parameters you can supply.

See the diagram below for a full overview of all methods and their functionality:



Generating Tournament Codes
To generate tournament codes:

Use /lol/tournament/v5/providers API endpoint to register as a provider in specific region while also setting a URL to be used for receiving game results notifications (HTTP POST). Returns providerID.
Use providerID to register a tournament for given Tournament Provider. Receive tournamentID in return.
Use tournamentID to generate one or more tournament codes for a given tournament using specific game settings, such as map, spectator rules, or pick type.
A tournament code should only be used to create a single match. If you reuse a tournament code, the server callback will not return stats for each match.
The method to generate tournament codes will return up to 1,000 tournament codes at a time. If needed, additional calls to this method can be made to create additional tournament codes.
Stale or unused tournament codes may be purged after a period of inactivity.
Tournament organizers can generate all the tournament codes they need in advance or generate them as necessary per each phase as shown below:

Server Callback
When a game created using tournament code has completed, the League of Legends servers will automatically make a callback to the tournament provider's registered URL through HTTP POST. Below are a couple notes about how the server callback works.

The provider registration and callback mechanism are relatively inflexible. For best results, use one of the valid generic top level domains (gTLDs) listed below and use HTTP over HTTPS for your callback URL while using the metaData field to validate callbacks.

Port Restrictions
The server callback supports http (port 80) and https (port 443) however Certificate Authorities (CA) approved after Jan 29, 2012 aren't supported. The callback server won't perform a callback if it is unable to validate an SSL cert issued by an unknown CA (and therefore doesn't trust).

Domain Restrictions
Only valid gTLDs approved by ICANN before March 2011 are considered valid. This excludes newer gTLDs such as (.mail, .xxx, .xyz, etc.)

Valid gTLDs (approved before March 2011)
aero, asia, biz, cat, com, coop, info, jobs, mobi, museum, name, net, org, pro, tel, travel, gov, edu, mil, int

Valid Country Code TLDs
ac, ad, ae, af, ag, ai, al, am, an, ao, aq, ar, as, at, au, aw, ax, az, ba, bb, bd, be, bf, bg, bh, bi, bj, bm, bn, bo, br, bs, bt, bv, bw, by, bz, ca, cc, cd, cf, cg, ch, ci, ck, cl, cm, cn, co, cr, cu, cv, cx, cy, cz, de, dj, dk, dm, do, dz, ec, ee, eg, er, es, et, eu, fi, fj, fk, fm, fo, fr, ga, gb, gd, ge, gf, gg, gh, gi, gl, gm, gn, gp, gq, gr, gs, gt, gu, gw, gy, hk, hm, hn, hr, ht, hu, id, ie, il, im, in, io, iq, ir, is, it, je, jm, jo, jp, ke, kg, kh, ki, km, kn, kp, kr, kw, ky, kz, la, lb, lc, li, lk, lr, ls, lt, lu, lv, ly, ma, mc, md, me, mg, mh, mk, ml, mm, mn, mo, mp, mq, mr, ms, mt, mu, mv, mw, mx, my, mz, na, nc, ne, nf, ng, ni, nl, no, np, nr, nu, nz, om, pa, pe, pf, pg, ph, pk, pl, pm, pn, pr, ps, pt, pw, py, qa, re, ro, rs, ru, rw, sa, sb, sc, sd, se, sg, sh, si, sj, sk, sl, sm, sn, so, sr, st, su, sv, sy, sz, tc, td, tf, tg, th, tj, tk, tl, tm, tn, to, tp, tr, tt, tv, tw, tz, ua, ug, uk, um, us, uy, uz, va, vc, ve, vg, vi, vn, vu, wf, ws, ye, yt, yu, za, zm, zw

The callback from the League of Legends server relies on a successful response from the provider's registered URL. If a 200 response is not detected, there is a retry mechanism that will make additional attempts. In the rare occasion that a callback is not received within 5 minutes, you can assume the callback failed.
If you need to change your provider callback URL, register a new provider but remember tournaments generated with the old provider will continue to make callbacks to the old provider callback URL.
When a game created using Tournament Code has completed, the League of Legends servers will automatically make a callback to the tournament provider's registered URL via HTTP POST. Below are a couple notes about how the server callback works.

If you are having trouble debugging your logic, use the following cURL to mimic the behavior of the callback:

curl <callback_url> -X POST -H "Content-Type: application/json" -d '<response_body>'
Below is a sample JSON response returned by the League of Legends servers when a callback is made:

{
  "startTime": 1234567890000,
  "shortCode": "NA1234a-1a23b456-a1b2-1abc-ab12-1234567890ab",
  "metaData": "{\"title\":\"Game 42 - Finals\"}",
  "gameId": 1234567890,
  "gameName": "a123bc45-ab1c-1a23-ab12-12345a67b89c",
  "gameType": "Practice",
  "gameMap": 11,
  "gameMode": "CLASSIC",
  "region": "NA1"
}
Lobby Events
In addition to game stats related methods, the lobby-events/by-code/{tournamentCode} method that can help query pre-game lobby events. This is useful for building tournament administration system and be able to detect whether a game for a given tournament code started normally. This call can be made both after the match for the full timeline and anytime during the lobby phase for a timeline of events up to that moment. Below is an example of the JSON returned for lobby events:

{
  "eventList": [
    {
      "timestamp": "1234567890000",
      "eventType": "PracticeGameCreatedEvent", //Lobby Created
      "summonerId": "12345678"
    },
    {
      "timestamp": "1234567890000",
      "eventType": "PlayerJoinedGameEvent", //Player Joins Lobby
      "summonerId": "12345678"
    },
    {
      "timestamp": "1234567890000",
      "eventType": "PlayerSwitchedTeamEvent", //Player Switches Teams
      "summonerId": "12345678"
    },
    {
      "timestamp": "1234567890000",
      "eventType": "PlayerQuitGameEvent", //Player Leaves Lobby
      "summonerId": "12345678"
    },
    {
      "timestamp": "1234567890000",
      "eventType": "ChampSelectStartedEvent"  //Champ Select Begins
    },
    {
      "timestamp": "1234567890000",
      "eventType": "GameAllocationStartedEvent"  //Loading Screen Begins
    },
    {
      "timestamp": "1234567890000",
      "eventType": "GameAllocatedToLsmEvent"  //Game Begins
    }
  ]
}
League Client API
What is the League Client API?
In an article on the Riot Games Engineering Blog, there's an image that is useful for defining what we're classifying as "League Client APIs".

Specifically, we're referring to a set of protocols that the Chromium Embedded Framework (CEF) uses to communicate with a C++ Library that in turn communicates with the League of Legends platform. As you'll notice, the communications between the C++ library and the CEF all occur locally on your desktop. This is the League Client API. This service is not officially supported for use with third party applications.

NOTE: We provide no guarantees of full documentation, service uptime, or change communication for unsupported services. This team does not own any components of the underlying services, and will not offer additional support related to them.



What's next
Whether you're combining the Riot Games API and League Client API, or doing something by only using the League Client endpoints, we need to know about it. Either create a new application or leave a note on your existing application in the Developer Portal. We need to know which endpoints you're using and how you're using them in order to expand on current or future feature sets. If you have any questions please join the Developer Discord for help.

Game Client API
The Game Client APIs are served over HTTPS by League of Legends game client and are only available locally for native applications.

 

NOTE: We provide no guarantees of full documentation, service uptime, or change communication for unsupported services. This team does not own any components of the underlying services, and will not offer additional support related to them.

Root Certificate/SSL Errors
The League of Legends client and the game client use a self-signed certificate for HTTPS requests. To use the Game Client API, you can ignore these errors or use the root certificate to validate the game client's SSL certificate. If you are testing locally, you can use the following insecure CURL that will ignore the SSL certificate errors.

curl --insecure https://127.0.0.1:2999/swagger/v3/openapi.json
Swagger
You can request the Swagger v2 and OpenAPI v3 specs for the Game Client API with the following URLs:
https://127.0.0.1:2999/swagger/v2/swagger.json
https://127.0.0.1:2999/swagger/v3/openapi.json

Live Client Data API
The Live Client Data API provides a method for gathering data during an active game. It includes general information about the game as well player data.

Get All Game Data
The Live Client Data API has a number of endpoints that return a subset of the data returned by the /allgamedata endpoint. This endpoint is great for testing the Live Client Data API, but unless you actually need all the data from this endpoint, use one of the endpoints listed below that return a subset of the response.

GET https://127.0.0.1:2999/liveclientdata/allgamedata
Get all available data.

You can find a sample response here.

Endpoints
Active Player
GET ​https://127.0.0.1:2999/liveclientdata/activeplayer
Get all data about the active player.

{
    "abilities": {...},
    "championStats": {
      "abilityHaste": 0.00000000000000,
      "abilityPower": 0.00000000000000,
      "armor": 0.00000000000000,
      "armorPenetrationFlat": 0.0,
      "armorPenetrationPercent": 0.0,
      "attackDamage": 0.00000000000000,
      "attackRange": 0.0,
      "attackSpeed": 0.00000000000000,
      "bonusArmorPenetrationPercent": 0.0,
      "bonusMagicPenetrationPercent": 0.0,
      "cooldownReduction": 0.00,
      "critChance": 0.0,
      "critDamage": 0.0,
      "currentHealth": 0.0,
      "healthRegenRate": 0.00000000000000,
      "lifeSteal": 0.0,
      "magicLethality": 0.0,
      "magicPenetrationFlat": 0.0,
      "magicPenetrationPercent": 0.0,
      "magicResist": 0.00000000000000,
      "maxHealth": 0.00000000000000,
      "moveSpeed": 0.00000000000000,
      "physicalLethality": 0.0,
      "resourceMax": 0.00000000000000,
      "resourceRegenRate": 0.00000000000000,
      "resourceType": "MANA",
      "resourceValue": 0.00000000000000,
      "spellVamp": 0.0,
      "tenacity": 0.0
    }
    "currentGold": 0.0,
    "fullRunes": {...},
    "level": 1,
    "summonerName": "Riot Tuxedo"
    "riotId": "Riot Tuxedo#TXC1",
    "riotIdGameName": "Riot Tuxedo",
    "riotIdTagLine": "TXC1"
}
GET ​https://127.0.0.1:2999/liveclientdata/activeplayername
Returns the player name.

"Riot Tuxedo"
GET ​https://127.0.0.1:2999/liveclientdata/activeplayerabilities
Get Abilities for the active player.

{
    "E": {
        "abilityLevel": 0,
        "displayName": "Molten Shield",
        "id": "AnnieE",
        "rawDescription": "GeneratedTip_Spell_AnnieE_Description",
        "rawDisplayName": "GeneratedTip_Spell_AnnieE_DisplayName"
    },
    "Passive": {
        "displayName": "Pyromania",
        "id": "AnniePassive",
        "rawDescription": "GeneratedTip_Passive_AnniePassive_Description",
        "rawDisplayName": "GeneratedTip_Passive_AnniePassive_DisplayName"
    },
    "Q": {
        "abilityLevel": 0,
        "displayName": "Disintegrate",
        "id": "AnnieQ",
        "rawDescription": "GeneratedTip_Spell_AnnieQ_Description",
        "rawDisplayName": "GeneratedTip_Spell_AnnieQ_DisplayName"
    },
    "R": {
        "abilityLevel": 0,
        "displayName": "Summon: Tibbers",
        "id": "AnnieR",
        "rawDescription": "GeneratedTip_Spell_AnnieR_Description",
        "rawDisplayName": "GeneratedTip_Spell_AnnieR_DisplayName"
    },
    "W": {
        "abilityLevel": 0,
        "displayName": "Incinerate",
        "id": "AnnieW",
        "rawDescription": "GeneratedTip_Spell_AnnieW_Description",
        "rawDisplayName": "GeneratedTip_Spell_AnnieW_DisplayName"
    }
}
GET ​https://127.0.0.1:2999/liveclientdata/activeplayerrunes
Retrieve the full list of runes for the active player.

{
    "keystone": {
        "displayName": "Electrocute",
        "id": 8112,
        "rawDescription": "perk_tooltip_Electrocute",
        "rawDisplayName": "perk_displayname_Electrocute"
    },
    "primaryRuneTree": {
        "displayName": "Domination",
        "id": 8100,
        "rawDescription": "perkstyle_tooltip_7200",
        "rawDisplayName": "perkstyle_displayname_7200"
    },
    "secondaryRuneTree": {
        "displayName": "Sorcery",
        "id": 8200,
        "rawDescription": "perkstyle_tooltip_7202",
        "rawDisplayName": "perkstyle_displayname_7202"
    },
    "generalRunes": [
        {
            "displayName": "Electrocute",
            "id": 8112,
            "rawDescription": "perk_tooltip_Electrocute",
            "rawDisplayName": "perk_displayname_Electrocute"
        },
        ...
    ],
    "statRunes": [
        {
            "id": 5007,
            "rawDescription": "perk_tooltip_StatModCooldownReductionScaling"
        },
        {
            "id": 5008,
            "rawDescription": "perk_tooltip_StatModAdaptive"
        },
        {
            "id": 5003,
            "rawDescription": "perk_tooltip_StatModMagicResist"
        }
    ]
}
All Players
GET ​https://127.0.0.1:2999/liveclientdata/playerlist
Retrieve the list of heroes in the game and their stats.

[
    {
        "championName": "Annie",
        "isBot": false,
        "isDead": false,
        "items": [...],
        "level": 1,
        "position": "MIDDLE",
        "rawChampionName": "game_character_displayname_Annie",
        "respawnTimer": 0.0,
        "runes": {...},
        "scores": {...},
        "skinID": 0,
        "summonerName": "Riot Tuxedo",
        "riotId": "Riot Tuxedo#TXC1",
        "riotIdGameName": "Riot Tuxedo",
        "riotIdTagLine": "TXC1",
        "summonerSpells": {...},
        "team": "ORDER"
    },
    ...
]
GET ​https://127.0.0.1:2999/liveclientdata/playerscores?riotId=
Retrieve the list of the current scores for the player.

{
    "assists": 0,
    "creepScore": 0,
    "deaths": 0,
    "kills": 0,
    "wardScore": 0.0
}
GET ​https://127.0.0.1:2999/liveclientdata/playersummonerspells?riotId=
Retrieve the list of the summoner spells for the player.

{
    "summonerSpellOne": {
        "displayName": "Flash",
        "rawDescription": "GeneratedTip_SummonerSpell_SummonerFlash_Description",
        "rawDisplayName": "GeneratedTip_SummonerSpell_SummonerFlash_DisplayName"
    },
    "summonerSpellTwo": {
        "displayName": "Ignite",
        "rawDescription": "GeneratedTip_SummonerSpell_SummonerDot_Description",
        "rawDisplayName": "GeneratedTip_SummonerSpell_SummonerDot_DisplayName"
    }
}
GET ​https://127.0.0.1:2999/liveclientdata/playermainrunes?riotId=
Retrieve the basic runes of any player.

{
    "keystone": {
        "displayName": "Electrocute",
        "id": 8112,
        "rawDescription": "perk_tooltip_Electrocute",
        "rawDisplayName": "perk_displayname_Electrocute"
    },
    "primaryRuneTree": {
        "displayName": "Domination",
        "id": 8100,
        "rawDescription": "perkstyle_tooltip_7200",
        "rawDisplayName": "perkstyle_displayname_7200"
    },
    "secondaryRuneTree": {
        "displayName": "Sorcery",
        "id": 8200,
        "rawDescription": "perkstyle_tooltip_7202",
        "rawDisplayName": "perkstyle_displayname_7202"
    }
}
GET ​https://127.0.0.1:2999/liveclientdata/playeritems?riotId=
Retrieve the list of items for the player.

[
    {
        "canUse": true,
        "consumable": false,
        "count": 1,
        "displayName": "Warding Totem (Trinket)",
        "itemID": 3340,
        "price": 0,
        "rawDescription": "game_item_description_3340",
        "rawDisplayName": "game_item_displayname_3340",
        "slot": 6
    },
    ...
]
Events
GET ​https://127.0.0.1:2999/liveclientdata/eventdata
Get a list of events that have occurred in the game.

{
    "Events": [
        {
            "EventID": 0,
            "EventName": "GameStart",
            "EventTime": 0.0325561985373497
        },
        ...
    ]
}
You can find a list of sample events here.

Game
GET ​https://127.0.0.1:2999/liveclientdata/gamestats
Basic data about the game.

{
  "gameMode": "CLASSIC",
  "gameTime": 0.000000000,
  "mapName": "Map11",
  "mapNumber": 11,
  "mapTerrain": "Default"
}
Any of these endpoints that returned a summonerName, now return a RiotID shim over summonerName, and new fields called riotId, riotIdGameName and riotIdTagLine in structured responses. Any endpoints that took a SummonerName as a parameter now accepts only the riotId parameter. It attempts to match the name to RiotID first, then RiotIDGameName, then SummonerName (to maintain backwards compatibility until we can fully deprecate SummonerName).

Replay API
The Replay API allows developers to adjust the in-game camera during replays. League Director is an open source example of how a tool can leverage the Replay API.

Getting Started
By default the Replay API is disabled. To start using the Replay API, enable the Replay API in the game client config by locating where your game is installed and adding the following lines to the game.cfg file:

Example file location:
C:\Riot Games\League of Legends\Config\game.cfg

[General]
EnableReplayApi=1
Once you have enabled the Replay API, the game client will generate the Swagger v2 and OpenAPI v3 specs for the Replay API, which indicates the Replay API is usable.

Endpoints
GET https://127.0.0.1:2999/replay/game
Information about the game client process.

GET https://127.0.0.1:2999/replay/playback
Returns the current replay playback state such as pause and current time.

POST https://127.0.0.1:2999/replay/playback
Allows modifying the playback state such as play/pause and the game time to seek to. All values are optional.

GET https://127.0.0.1:2999/replay/render
Returns the current render properties.

POST https://127.0.0.1:2999/replay/render
Allows modifying the current render properties. All values are optional.

GET https://127.0.0.1:2999/replay/recording
Returns the current status of video recording. Poll this resource for progress on the output.

POST https://127.0.0.1:2999/replay/recording
Post to begin a recording specifying the codec and output filepath. Subsequent GET requests to this resource will update the status.

GET https://127.0.0.1:2999/replay/sequence
Returns the sequence currently being applied.

POST https://127.0.0.1:2999/replay/sequence
Post to apply a sequence of keyframes that the replay should play. Post an empty object to remove the sequence.

Working with LoL APIs
Game Constants
When looking up specific seasons, queues, maps, and modes it is important to use the correct IDs.

Seasons
Season IDs are used in match history to indicate which season a match was played. A full list of season ids can be found in seasons.json.

[
  {
    "id": 0,
    "season": "PRESEASON 3"
  },
  ...
]
Queue IDs
Queue IDs show up in several places throughout the API and are used to indicate which kind of match was played. A full list of queue ids can be found in queues.json.

Note: In early 2022, URF (previously queueId 900) was divided into separate queues— ARURF (queueId 900) and Pick URF (queueId 1900). All Pick URF games from before this distinction will still be in queueId 900.

[
  {
    "queueId": 0,
    "map": "Custom games",
    "description": null,
    "notes": null
  },
  ...
]
Maps
Map IDs are used in match history to indicate which map a match was played. A full list of map IDs can be found in maps.json.

[
  {
    "mapId": 1,
    "mapName": "Summoner's Rift",
    "notes": "Original Summer variant"
  },
  ...
]
Game Modes
A full list of game modes can be found in gameModes.json.

[
  {
    "gameMode": "CLASSIC",
    "description": "Classic Summoner's Rift and Twisted Treeline games"
  },
  ...
]
Game Types
A full list of game types can be found in gameTypes.json.

[
  {
    "gameType": "CUSTOM_GAME",
    "description": "Custom games"
  },
  ...
]
Ranked Info
Queue Types
The League endpoints return a field called queueType that indicates what map/mode a player played. Depending on the queueType, the highestTierAchieved field returns the highest ending tier for the previous season from a group of ranked queues.

Here is a list of all of the queueType and highestTierAchieved for each.

Summoner's Rift
Unranked
    RANKED_SOLO_5x5
    RANKED_TEAM_5x5
Ranked Solo/Duo
    RANKED_SOLO_5x5
Ranked Team 5x5
    RANKED_TEAM_5x5
Other Maps
If a match is not played on Summoner's Rift, the highestTierAchieved field will return the highest ending tier for the previous season from any ranked queue.

Icons and Emblems
The most recent emblems assets for all ranks can be found below.ranked-emblems-latest.zip

Older tier icon assets can be found below.



ranked-emblems.zip
ranked-positions.zip



tier-icons.zip

Getting Help and Staying Up-to-date
If you run into any difficulties or are having technical issues, please join Developer Discord for support. Follow our Twitter for the latest updates.

Developer Portal Overview
9 months ago Updated
Overview
This document will provide you with a basic understanding of the Riot Games Developer Portal. It is designed to help you begin exploring and developing your own tools and products to positively impact the experience for players of Riot's games. We can't wait to see what you make!

Getting Started
Before you can begin taking advantage of the Developer Portal, you must login with your Riot Games account. Once you do, a Developer Portal account is created for you! This action also generates a basic development API key that is associated with your account. We'll talk about how you can interact with Riot to enhance that key further on in this documentation.

This account gives you the option to register your product proposal with Riot's Developer Relations team. Once you've registered your product you can communicate with our team for approvals, increased access, and more.

Product Registration
If you're here, you're probably thinking about making a cool application or website for a Riot game. For simplicity, we'll broadly call those things "products". As mentioned above, once you've logged in to the Developer Portal, you'll be able to register your product proposal. Let's go over what that entails.

Application Process
First off, every product owner (developer) will be expected to have read and understood our policies. You can find them in the nav bar at the top of this page. Read them. Failure to adhere to these policies may lead to punitive actions, so make sure you understand them before going too far forward.

Even if your product doesn't use the Riot Games API, you'll find it beneficial to register your product. Registration lets Riot know you're out there, doing great stuff. If we know you're out there, then we can keep you informed of opportunities that might be beneficial to you and your product(s). Also, you will have a pathway to let us know how Riot can better help you and other developers.

So, how do you get registered?

It's simple. Head back to the main page of the Developer Portal and click the Register Product button. From there you'll need to decide if this is for a larger scale product, or a personal project. From there we'll ask you to fill out an online form that gathers some key details about your product. Finally, we'll ask you to verify your product, just to make sure you're really the developer!

Once you've completed those steps, our Developer Relations team will review your proposal. If everything is in order, we'll approve your product, and you're on your way to unlocking additional rate limits for your API key, and building a relationship with the team to help improve your product.

If your product is approved, we expect you to keep it in compliance of all applicable rules, policies, and laws. It's on you to stay up to date on all of those. If you need help with that, leave us a message in the Developer Portal, or jump into the Developer Discord.

If your product proposal is rejected, we'll be sure to leave you a message in the Developer Portal. We want you to succeed, so feel free to work with us through that messaging system to address our concerns, and get your great idea into the hands of players.

When reviewing applications we take a look at a lot of factors to determine if it's something that will benefit the Riot Games ecosystem. Of note, we want to make sure that the product doesn't violate any laws or existing policies. We'll also want to make sure that the product helps players in some measurable way. We want to see product that help players get better at our games, or track their growth. What we don't want to see are products that solve our games or make everything too simple. Also, we are looking for quality. If your website isn't complete, we're unlikely to approve your product. If you have questions, though, just send us a message at our Support Site..

About that messaging system...

 

Messages
We’ll send approval and rejection notifications to you directly in your application messages on the Developer Portal. If we have questions about a pending application, we’ll be sure that you have a way to respond to us on the Developer Portal.

If you have questions specific to your product registration, you can send a message on our Support Site to get some feedback. Using the Support Site is the surest and quickest way to get a response from the Developer Relations team. Further, if you have any questions about your live products or anything else in the ecosystem, you can submit a message and we'll respond.

A caveat: Don't use the messaging system irresponsibly. This isn't a channel for you to casually chat with Rioters. This is a business channel, and should be treated as such.

Web APIs
Your product might depend on the Riot Games API. If it does, you'll need to be sure you understand some basic concepts about your Riot Games API key.

API Keys
Anyone who signs into the developer portal will automatically be granted an API key that will be associated with their account. Your API key allows you to start using the API immediately, and allows us to generate API usage metrics for your key. In all, we manage several types of API keys. See the differences below.

DEVELOPMENT API KEYS
The API key that was generated for you when you signed into the developer portal is a development API key. These interim API keys are temporarily granted for products that are not meant for public consumption but benefit from temporary access to the API. The purpose of a development API key is for you to tinker with the Riot Games API and potentially develop a prototype for a product that you can make available for the community to use. They also deactivate every 24 hours. You'll need to regularly reset yours to keep it live.

PERSONAL API KEYS
You may apply for a personal API key by registering your product. Personal API keys should be used for products that are intended for just the developer or a small private community. These products can be registered without the verification process, but won't be approved for rate limit increases. You may request access to the Standard APIs, but not the Tournaments API. Personal keys require a detailed description of the product.

Acceptable uses for a personal API key include:

bots for streaming sites, boards, voice com servers, etc.
to display your own personal stats for your personal website
personal projects to gather your own stats
personal research
projects meant for personal usage and not production
The rate limit for a personal keys is by design very limited:

20 requests every 1 second
100 requests every 2 minutes
Note that rate limits are enforced per region. For example, with the above rate limit, you could make 20 requests every 1 second to both the NA and EUW League of Legends endpoints simultaneously.

You may not run your application for public consumption using a personal key, regardless of how long the approval process for your production key takes. Note that public consumption includes open alpha/beta tests.

PRODUCTION API KEYS
If you have developed an application using the Riot Games API that you would like to open up to players, you should apply for a production API key. You may not maintain a public product with a development API key. Production API keys have a much higher rate limit suitable for sustaining a public product's traffic.

Production API keys should be used for products that are intended for large communities or the Internet as a whole. You may request access to the Standard APIs and the Tournaments API. Typically requires a working prototype before receiving an API key.

The starting rate limit of a production API key is much larger than the development key:

500 requests every 10 seconds
30,000 requests every 10 minutes
Remember that this rate limit is enforced per region.

To apply for a production key with an expanded rate limit, click "Register Project" on your dashboard. The process and length of time required to obtain an approved production key can vary depending on your project and the application's target region(s).

Note that the standard production rate limit will meet the needs of the large majority of developers, but it can be expanded if the developer is in good standing, has demonstrated a strong community benefit, and has steadily outgrown the standard production limit.

If you are working on multiple projects, you should register each one separately and each one needs to be individually approved for a separate production API key.

API KEY SECURITY
As a final note on API keys, it's important to mention that your key will likely end up revoked if it isn't properly secured. Securing your API key is a requirement to publishing a project as outlined in the General Policies. If we determine that your key is not secured appropriately, we'll take action to secure it for you. :)

Response Codes
The Riot Games API returns all data in valid JSON. A few programming languages include native support for JSON. For those that don't, you can find a suitable library at https://json.org/.

Note that our APIs return only non-empty values to save on bandwidth. Zero is considered an empty value, as well as empty strings, empty lists, and nulls. Any numeric field that isn't returned can be assumed to be 0 (or null as you prefer). Any list field that isn't returned can be assumed to be an empty list or null. Any String field that isn't returned can be assumed to be empty string or null.

2XX RESPONSE CODES
For 200 response codes, you can always expect the response body documented on the API reference page. Only 200 response codes are guaranteed to return a response body as JSON.

For non-200 response codes please be aware of the following:

A response body is not guaranteed to be returned.

If there is a response body, its not guaranteed to be JSON.
We currently return JSON with human readable debugging information, but the structure and content of this debugging information are subject to change. As an example...
    {
        "status": {
            "message": "Unauthorized",
            "status_code": 401,
        }
    }
The contents of status, message, and status_code are not guaranteed to always exist or remain constant for a given response code. 4. Logic within your application should fail gracefully based the response code alone, and should not rely on the response body.

4XX ERROR CODES
The 4xx class of error codes is meant to indicate that the client failed to provide a valid request. Below are the most common 4xx class of error codes you might encounter when using the API.

400 (Bad Request) This error indicates that there is a syntax error in the request and the request has therefore been denied. The client should not continue to make similar requests without modifying the syntax or the requests being made.

Common Reasons

A provided parameter is in the wrong format (e.g., a string instead of an integer).
A provided parameter is invalid (e.g., beginTime and startTime specify a time range that is too large).
A required parameter was not provided.
401 (Unauthorized) This error indicates that the request being made did not contain the necessary authentication credentials (e.g., an API key) and therefore the client was denied access. The client should not continue to make similar requests without including an API key in the request.

Common Reasons

An API key has not been included in the request.
403 (Forbidden) This error indicates that the server understood the request but refuses to authorize it. There is no distinction made between an invalid path or invalid authorization credentials (e.g., an API key). The client should not continue to make similar requests.

Common Reasons

An invalid API key was provided with the API request.
A blacklisted API key was provided with the API request.
The API request was for an incorrect or unsupported path.
404 (Not Found) This error indicates that the server has not found a match for the API request being made. No indication is given whether the condition is temporary or permanent.

Common Reasons

The ID or name provided does not match any existing resource (e.g., there is no Summoner matching the specified ID).
There are no resources that match the parameters specified.
415 (Unsupported Media Type) This error indicates that the server is refusing to service the request because the body of the request is in a format that is not supported.

Common Reasons

The Content-Type header was not appropriately set.
429 (Rate Limit Exceeded) This error indicates that the application has exhausted its maximum number of allotted API calls allowed for a given duration. If the client receives a Rate Limit Exceeded response the client should process this response and halt future API calls for the duration, in seconds, indicated by the Retry-After header. Applications that are in violation of this policy may have their access disabled to preserve the integrity of the API. Please refer to our Rate Limiting documentation below for more information on determining if you have been rate limited, and how to avoid it.

Common Reasons

Unregulated API calls.
5XX ERROR CODES
The 5xx class or error codes indicates that the server is aware it has errored or is incapable of performing the request. Below are the most common 5xx class of error codes you might encounter when using the API.

500 (Internal Server Error) This error indicates an unexpected condition or exception which prevented the server from fulfilling an API request.

503 (Service Unavailable) This error indicates the server is currently unavailable to handle requests because of an unknown reason. The Service Unavailable response implies a temporary condition which will be alleviated after some delay.

Rate Limiting
In order to control the use of the Riot Games API, we set limits on how many times endpoints can be accessed within a given time period. These limits are put in place to minimize abuse, to maintain a high level of stability, and to protect the underlying systems that back the API from being overloaded. The underlying systems are the same systems that power our games, so if they are overloaded, player experience suffers, and our first priority is to protect that experience.

RATE LIMITING TYPES
There are three types of limits used in the API infrastructure - application, method and service rate limits.

Application Rate Limits
The first type of limit is enforced on a per API key basis and is called an application rate limit. App rate limits are enforced per region. Every call made to any Riot Games API endpoint in a given region counts against the app rate limit for that key in that region. For example, calls to the static data API do not count against the application rate limit.

Method Rate Limits
The second type of limit is enforced on a per endpoint (or "method") basis for a given API key and is called a method rate limit. Method rate limits are also enforced per region. Every call made to any Riot Games API endpoint in a given region counts against the method rate limit for the given method and API key in that region.

Service Rate Limits
The third type of limit is enforced on a per service basis and is called a service rate limit. Service rate limits are also enforced per region. Every call made to any endpoint for a given Riot Games API service in a given region counts against the service rate limit for that service in that region. When service rate limits apply, we will document them, including which endpoints are part of the rate limited service.

Do not confuse method rate limits for service rate limits. Method rate limits apply individually to each application. Service rate limits apply to the service, and are shared by all applications making calls to a service.

Other Limits
These limits enforced by the API infrastructure are not the only gateways to the data provided. Some of the underlying services for certain endpoints may also implement their own rate limits, independently of the API infrastructure. In these cases, you will get a 429 error response, but there will be no X-Rate-Limit-Type header included in the response. Only when the rate limiting is enforced by the API edge infrastructure will this header be included.

While it is our policy not to reveal the specifics of how our rate limiting works, you can assume for the purposes of your code that the bucket starts when you make your first API call.

Versioning
As of 2019, these versioning guidelines apply to all Riot Games APIs. However, this may change in the future. Be sure to check documentation for each game you are developing products for to be sure you have the latest information.

Currently, all League of Legends APIs are version 4. We no longer include a minor version in the API path.

Deprecation
As of 2019, these deprecation guidelines apply to all Riot Games APIs. However, this may change in the future. Be sure to check documentation for each game you are developing products for to be sure you have the latest information.

Whenever we deprecate, or make changes to, an API we aim to support both old and new versions of the API for 60 days. After that time the old version is deprecated. At times, circumstances require deprecation periods to be longer or shorter than 60 days. Deprecation periods will be communicated to developers through social media and the Developer Relations blog.

Developers should be careful when developing products with the Riot Games API. If an API is deprecated in favor of an updated version, the previous version will no longer be available. Any calls from a valid API key to a deprecated endpoint will result in an error code.

OAuth Client Documentation
7 months ago Updated
OAuth Client Documentation
Discover more about using OAuth, including an in-depth tutorial and frequently asked questions.


OAuth Integration
All apps must request that users opt-in to sharing their personal data. To do this, your application will need to verify players using an OAuth flow, which is done through an OAuth client.


Getting a Production Key
Before you can get started with OAuth, you need a production key. If you don't have one, create one at developer.riotgames.com. We'll contact you using the email linked to your developer account to kick off the OAuth integration process.


Requesting an App
To request an app, fill out the form.


After your App is Approved
Before making any calls with your app, verify that you have an approved, functioning production application in the Developer Portal and a separate, approved app (we will have created this for you) with an app ID that matches exactly what we send you in an email.

Here's where you direct players to login:

https://auth.riotgames.com/authorize?client_id=&redirect_uri=&response_type=code&scope=openid+offline_access
 
The authorization code is intended to be a one-time use token that can be exchanged for an access token.
After logging in, players are redirected back to the redirect_uri you specified. Here's information about how to integrate with OAuth and to view a sample Node web server that implements the example:

Implementing OAuth
Download OAuth Node App Example
Your app has access to endpoints that lets you identify who logged in.

 
VALORANT
Use https://developer.riotgames.com/apis#account-v1/GET_getByAccessToken

curl --location --request GET 'https://americas.api.riotgames.com/riot/account/v1/accounts/me' --header 'Authorization: Bearer {accessToken}'

curl --location --request GET 'https://europe.api.riotgames.com/riot/account/v1/accounts/me' --header 'Authorization: Bearer {accessToken}'

curl --location --request GET 'https://asia.api.riotgames.com/riot/account/v1/accounts/me' --header 'Authorization: Bearer {accessToken}'
The data return from each cluster is identical. We recommend using the cluster closest to your servers.

 
League of Legends
Use https://developer.riotgames.com/apis#summoner-v4/GET_getByAccessToken

curl --location --request GET 'https://na1.api.riotgames.com/lol/summoner/v4/summoners/me' --header 'Authorization: Bearer {accessToken}'
You'll need to include the cpid (current platform id) scope when directing the user to login, so that the OAuth access token is generated with the cpid scope. The cpid scope will ensure the cpid field is returned when making requests to https://auth.riotgames.com/userinfo. Once you determine the user's current platform id (cpid) then you can make requests to the DNS associated with their current platform. (for example, https://na1.api.riotgames.com)

 

Teamfight Tactics
Use https://developer.riotgames.com/apis#tft-summoner-v1/GET_getByAccessToken

curl --location --request GET 'https://na1.api.riotgames.com/tft/summoner/v1/summoners/me' --header 'Authorization: Bearer {accessToken}'
You'll need to include the cpid (current platform id) scope when directing the user to login, so that the OAuth access token is generated with the cpid scope. The cpid scope will ensure the cpid field is returned when making requests to https://auth.riotgames.com/userinfo. Once you determine the user's current platform id (cpid) then you can make requests to the DNS associated with their current platform. (for example, https://na1.api.riotgames.com)

 
Legends of Runeterra
Use https://developer.riotgames.com/apis#account-v1/GET_getByAccessToken

curl --location --request GET 'https://americas.api.riotgames.com/riot/account/v1/accounts/me' --header 'Authorization: Bearer {accessToken}'

curl --location --request GET 'https://europe.api.riotgames.com/riot/account/v1/accounts/me' --header 'Authorization: Bearer {accessToken}'

curl --location --request GET 'https://asia.api.riotgames.com/riot/account/v1/accounts/me' --header 'Authorization: Bearer {accessToken}'
The data return from each cluster is identical. We recommend using the cluster closest to your servers.

Implementing Riot Sign On (web tutorial)
This tutorial provides guidance for implementing Riot Sign On (RSO) from initially connecting the service, serving a Sign In link, authenticating the user, to processing the user’s tokens.


To start working with RSO, you will need the following:

Riot Sign On — hosted at https://auth.riotgames.com. Use this to authenticate during this process.
/authorize — endpoint for obtaining an authorization code
/token — endpoint to exchange authorization codes for access, identity, and refresh tokens
/jwks.json — endpoint to obtain JSON Web Keys for verifying the authenticity of access and identity tokens
(optional) /userinfo — endpoint to use your Access Token to obtain user information
For this process, add 127.0.0.1 local.example.com to your /etc/hosts file
Register a client — use this to ensure you have credentials to use with Riot Sign On
the client must be registered to allow http://local.example.com:3000/oauth2-callback as a redirect_uri.
The service must be secured with https
Access to standard NPM libraries to run the Node.js code examples in this process.

Registering a New RSO Client
Follow the instructions on the RSO Client Request Form to submit a request for an RSO client. Older clients may continue to use client secret basic and receive a client_secret, but newer clients will receive a few fields to support private key JWT client auth, such as:


client_id
public key
private key
example signed 100 year token (JWT)

Note: The Private key that is generated on your behalf is not stored and cannot be retrieved.  New keypairs can be generated without disabling the old keypair.


If you are familiar with JWT signing, you may choose to implement proper token minting using the returned private key for increased security.


If you are not familiar with JWTs and signing, continue to use the example 100 year token as your client assertion in the code examples in this process, but be sure to store and treat it as you would a plaintext password.


Note: If you want locale-specific values for client name, logo uri, privacy policy uri, and terms of service, after your client is created, please respond with the list using the following form:  <field>#<locale>, for example,  privacy policy url#de_DE: <url>


Use the following Riot-supported locales: cs_CZ, de_DE, el_GR, en_AU, en_GB, en_PL, en_US, es_AR, es_ES, es_MX, fr_FR, hu_HU, it_IT, ja_JP, pl_PL, pt_BR, ro_RO, ru_RU, tr_TR.

Understanding the Authorization Code Flow
The Authorization Code flow consists of the following:


/ - the index page, a place where to access a ‘Sign In’ link
/oauth2-callback - Where Riot Sign On is requested to redirect the player after a successful Sign In.
var express = require('express'),
   app = express();

app.get('/', function(req, res) {
   res.send("index");
});

app.get('/oauth2-callback', function(req, res) {
   res.send("callback");
});

var server = app.listen(3000, function () {
   var host = server.address().address;
   var port = server.address().port;

   console.log('Example app listening at http://%s:%s', host, port);
});

Sending Users to Riot Sign On
The purpose of route / is to deliver a Sign In link that the player can click to authenticate against Riot Sign On. Riot Sign On expects several parameters passed to it or it will throw an error indicating something not included. Make sure the following fields are included:

Mandatory fields
redirect_uri - the OAuth 2 Callback route set up on the Riot server. This route needs to be able to process a code query parameter that is added to the URI on when Riot Sign On redirects the player back to the URI. Make sure to have this URI added as one of the redirect_uris during client registration. In this example, use http://local.exmaple.com:3000/oauth2-callback
client_id - ID assigned to client during registration. This will be the Client ID when you registered a client during the first part of this process.
response_type - response type expected, should be code for authorization code flow
scope - a predefined data scope, must include openid to authenticate.
Additional scopes that can be requested are:
cpid - returns the game region for League of Legends.
offline_access - allows Refresh Tokens to be used to retrieve new access_tokens that have access to the /userinfo endpoint
Optional fields
login_hint - field used to specify hints to pre-populate data on the Login Page. Supports several formats:
{regioncode} - lowercase region code, for example, dev9
{regioncode}|{username} - lowercase region code, pipe, and username, for example, dev9|daguava
{regioncode}#{userid} - lowercase region code, hash, and user ID, for example, dev9#2054
ui_locales - space-separated list of player’s preferred BCP47 language tag values in order of most to least preferred.
state - an opaque value provided to the authorize endpoint. The same value is returned to you when the endpoint sends its reply. Enables you to compare value sent and received, to prevent CSRF.

Using all the mandatory fields, the Sign In link is:

https://auth.riotgames.com/authorize?redirect_uri=http://local.leagueoflegends.com:3000/oauth2-callback&client_id=oujzg5jiibvzo&response_type=code&scope=openid

Modifying the code to make the Sign In link a bit more portable, the server.js now looks as follows:

. . .
var appBaseUrl      = "http://local.example.com:3000",
   appCallbackUrl  = appBaseUrl + "/oauth2-callback";

var provider        = "https://auth.riotgames.com",
   authorizeUrl    = provider + "/authorize";

var clientID        = "oujzg5jiibvzo";

app.get('/', function(req, res) {
   var link = authorizeUrl
           + "?redirect_uri=" + appCallbackUrl
           + "&client_id=" + clientID
           + "&response_type=code"
           + "&scope=openid";
   // create a single link, send as an html document
   res.send('<a href="' + link + '">Sign In</a>');
});
. . .

Here, the player is presented with the Login Page of Riot Sign On, and may sign in.

Response from Riot Sign On
When the player successfully logs in, a 302 Redirect sends their browser to the redirect_uri that was included in the Sign In link.

Note: The callback route http://local.example.com:3000/oauth2-callback does not do anything yet.

This route receives a code as a url query-string parameter, and the server must then make a server-to-server request to exchange this code for Access, Identity, and Refresh Tokens. You must send the following to Riot Sign On’s Token endpoint to receive these Tokens back:

Authorization: Basic ... - Set an Authorization Header. The format of this header is "Basic " + Base64Encode(client_id + ":" + client_secret)
form data
grant_type - Tell Riot Sign On you are working with the authorization_code grant type.
code - Pass Riot Sign On the access code, which was received as a querystring parameter to the oauth2-callback route: ...com:3000/oauth2-callback?code=CxhkPgX8GiMKR4-E-YD8Ng
redirect_uri - Pass in the same redirect_uri used before.
To simplify making requests, use the request package. The basic callback route using private key JWT, looks as follows:

. . .

var request = require('request');

var clientAssertion = "your-signed-jwt-here";

var appBaseUrl      = "http://local.example.com:3000",
   appCallbackUrl  = appBaseUrl + "/oauth2-callback";

var provider        = "https://auth.riotgames.com",
   authorizeUrl    = provider + "/authorize",
   tokenUrl        = provider + "/token";

. . .

app.get('/oauth2-callback', function(req, res) {
   var accessCode = req.query.code;

   // make server-to-server request to token endpoint
   // exchange authorization code for tokens
   request.post({
       url: tokenUrl,

       form: { // post information as x-www-form-urlencoded
           client_assertion_type: "urn:ietf:params:oauth:client-assertion-type:jwt-bearer",
           client_assertion: clientAssertion,
           grant_type: "authorization_code",
           code: accessCode, // accessCode should be url decoded before being set here
           redirect_uri: appCallbackUrl
       }
   }, function (error, response, body) {
       // do something with the response?
   });

});

The following example uses Client Secret Basic:

. . .

var request = require('request');

var clientID     = "your-client-id-here",
   clientSecret = "your-client-secret-here";

var appBaseUrl      = "http://local.example.com:3000",
   appCallbackUrl  = appBaseUrl + "/oauth2-callback";

var provider        = "https://auth.riotgames.com",
   authorizeUrl    = provider + "/authorize",
   tokenUrl        = provider + "/token";

 . . .

app.get('/oauth2-callback', function(req, res) {
   var accessCode = req.query.code;

   // make server-to-server request to token endpoint
   // exchange authorization code for tokens
   request.post({
       url: tokenUrl,
       auth: { // sets "Authorization: Basic ..." header
           user: clientID,
           pass: clientSecret
       },
       form: { // post information as x-www-form-urlencoded
           grant_type: "authorization_code",
           code: accessCode, // accessCode should be url decoded before being set here
           redirect_uri: appCallbackUrl
       }
   }, function (error, response, body) {
       // do something with the response?
   });

});

A raw Token endpoint response looks similar to:

{  
 "scope":"openid",
 "expires_in":600,
 "token_type":"Bearer",
 "refresh_token":"dXJuOnJpb3Q6cOk1qdNal ... 8zN3NzbQ.xw96rZeGEMtrFlDCGLyA",
 "id_token":"eyJhbGciJSUzI1mtpZCInMxIn0 ... YiI6InVybjpyaW90OpZDp2MTpNalV",
 "sub_sid":"vldfsXGdDPoafSKfjS932cslKu8JDUKZ-woZvXDoq8",
 "access_token":"eyJhbGciOi1NsImZCI6InM ... NTkzMTA3LCJjaWQiJnmE-BVnZbYqY"
}

Change the callback of the response to parse this and get the Tokens.

request.post({
   . . .
}, function (error, response, body) {
   if (!error && response.statusCode == 200) {
       // parse the response to JSON
       var payload = JSON.parse(body);

       // separate the tokens from the entire response body
       var tokens = {
           refresh_token:  payload.refresh_token,
           id_token:       payload.id_token,
           access_token:   payload.access_token
       };

       // legibly print out our tokens
       res.send("<pre>" + JSON.stringify(tokens, false, 4) + "</pre>");
   } else {
       res.send("/token request failed");
   }
});

The following is an explanation of the fields in the response:

scope - Details what level of access the given Access Token provides. See the Scopes list for more information.
expires_in - The life span (in seconds)
token_type - Method of authorization token provides. Bearer means the entire Token should be provided.
Bearer eyJhbGciOi1NsImZCI6InM ... NTkzMTA3LCJjaWQiJnmE-BVnZbYqY
sub_sid - The identifier of an existing session (SID) for the subject (player).
refresh/id/access_token - Detailed in the following section.
Using Tokens and Verification
The Access and ID Tokens are received as the final step of a grant. Access Tokens are used for scoped authentication of a client and player to a resource, while ID Tokens provide information necessary to authenticate a player’s identity. ID Tokens are usually set as a cookie in the user’s browser to establish identity between pages and services.

Riot Sign On Access and ID Tokens are encoded as Signed JSON Web Tokens (JWT) to prevent tampering. Additionally, Access Tokens are encrypted and cannot be decoded.

Refresh Tokens are used to obtain a new Access Token when a given Access Token has expired, and have a much longer lifespan than an Access Token. The expiration flow of Access Tokens ensures that even if one is compromised, it has a very limited life-span.

IMPORTANT

It is important to note that Access Tokens are encrypted and cannot be decoded or verified.

Example
Once complete, a full example provides the following:

A Sign In link to the player
The link takes the user to Riot Sign On to log in
The player is redirected back to our redirect_uri with an access code appended to the URL
The Oauth2-Callback route exchanges the access code for tokens
A server-to-server request is made to exchange the code for Access, Identity, and Refresh Tokens
Riot Games verifies the authenticity of these tokens

You can now send a player to Riot to authenticate, receive the auth code returned. and exchange it for Access, Identity, and Refresh tokens.

Using Refresh Tokens
The Refresh Token is issued for the purpose of obtaining new Access Tokens when an older one expires. RSO Refresh tokens are self-contained, signed JSON Web Tokens (JWT) that can be inspected and validated locally.


Category

Description

Format

JWT signed

Refreshable?

N/A

Usage

Obtain a new Access Token

Visibility To Javascript

No

Visibility To User

No

Visibility To Server

Yes


Example encrypted token:


dXJuOnJpb3Q6cGlkOnYxOk1qVXdNalE2UkVWV09R.Z2pyamNvaG8zN3NzbQ.xw96rZeGEmeMtrFlDCGLyA


Using a Refresh Token
Refresh Tokens are only used to obtain a new Access Token, usually when the previous one has expired due to time expiration or revocation.


Headers


    Authorization: Basic Z2pyamNvaG8NzbTpPLWpTb ... tkcEN6amp13U2ZTOWpjU0w=

POST-Data


    grant_type:    refresh_token

    refresh_token: dXJuOnJpb3Q6cGlknYxO ... G8zN3NzbQ.xw96rZEmeMtrFlDCGLyA

    (optional) scope: [ same or narrower scope ]


URI

    https://auth.riotgames.com/token


Response:


{  

    "scope":"openid",

    "expires_in":600,

    "token_type":"Bearer",

    "refresh_token":"dXJuOnJpb3Q6cGlkOn ... amNvaG8zN3NzbQeGEmeMtrFlDCGLyA",

    "access_token":"eyJhbGciOiJSUzI1NiI ... sFwkadLmWmwtvJouhX22Tc6vPnfXTk"

}


When using a Refresh Token, there are two actions RSO may take. If it replies with a new Refresh Token, it must be used in all future Access Token refreshes and the previous Refresh Token is now invalid.

If the same Refresh Token is received in the response, you may continue to use it in future refresh requests.



Accessing the Userinfo Endpoint
The UserInfo endpoint is a protected RSO endpoint where client applications can retrieve consented claims, or assertions, about the logged in player.


The claims are typically packaged in a JSON object where the sub member denotes the subject (player) identifier.


This is the first endpoint established to support Bearer access tokens from Implementing Authorization Codes on the Web.


Creating a Request

Headers

    Authorization: Bearer eyJhbGciOiJSUzI ... axZMUW2WchZU9fGHM_h61A

URI

    https://auth.riotgames.com/userinfo


Response

{

  "sub": "2SqiN9ZWecDMZdo-y3Xaaoos32kTazZQDgzOyxzJe66SzGYqIljuuxjmctK0-XbBIhzZn929LZnH5S90L4vNVjx7En27”,

  "cpid": "NA1"

}
