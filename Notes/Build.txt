# EloWard Implementation Plan

## System Overview
EloWard consists of two primary components:
1. **Chrome Extension**: Displays League of Legends rank badges in Twitch chat
2. **Streamer Web Application**: Manages streamer subscriptions and settings

This separation follows industry best practices (similar to 7TV and BetterTTV) by keeping the extension focused on core functionality while handling subscription management and payments through a dedicated web platform.

## Tech Stack

### Chrome Extension
- **Frontend**: JavaScript, HTML, CSS
- **Storage**: Browser local storage for user preferences and caching
- **APIs Used**: Riot Games API (via Cloudflare Workers proxy)

### Streamer Web Application
- **Frontend**: React.js with Material UI (deployed on Cloudflare Pages)
- **Backend**: Cloudflare Workers and Functions
- **Database**: Cloudflare D1 (SQLite database)
- **Authentication**: Twitch OAuth
- **Payment Processing**: Stripe

### Shared Backend Services
- **API Server**: Cloudflare Workers
- **Caching Layer**: Cloudflare KV for performance optimization
- **Rate Limiting**: Built-in Cloudflare rate limiting for Riot API requests
- **Deployment**: Cloudflare Pages and Workers

## Implementation Steps

### 1. Extension Development

#### 1.1 Project Setup
- Create GitHub repository for extension
- Initialize Chrome extension manifest.json (v3)
- Set up development environment and folder structure

#### 1.2 Core Extension Components
- **Manifest.json**: Define minimal required permissions
- **Background Service Worker**: Handle authentication and API calls
- **Content Scripts**: Inject functionality into Twitch pages
- **Popup Interface**: User settings and account linking

#### 1.3 Authentication System (Viewers)
- Implement Riot RSO integration via secure backend proxy
  - Register application with Riot Developer Portal (admin only)
  - Set up OAuth flow for League account verification
  - Store credentials in local storage with appropriate security
  - Use backend proxy to protect client credentials

#### 1.4 Twitch Integration
- Create content script system to identify and modify chat:
  - Observer pattern to watch for new messages
  - Username extraction from chat messages
  - Check channel subscription status before displaying badges
  - Badge insertion next to usernames in subscribed channels only
- Implement MutationObserver for dynamic content
- Ensure compatibility with Twitch's interface changes

#### 1.5 Riot API Integration (Client-Side)
- Implement API calls to backend proxy
- Set up local caching system
- Create badge rendering based on rank data

#### 1.6 User Settings
- Create popup interface for:
  - League account linking
  - Badge display preferences
  - Opt-out option
- Implement local storage for settings persistence

### 2. Web Application Development

#### 2.1 Project Setup
- Create separate GitHub repository for web app
- Set up React project with necessary dependencies
- Configure Cloudflare Pages for automatic deployment
- Set up Cloudflare Pages Functions for backend functionality

#### 2.2 Authentication System (Streamers)
- Implement Twitch OAuth integration
  - Register application with Twitch Developer Portal
  - Set up secure authentication flow
  - Store Twitch ID as primary identifier

#### 2.3 Subscription Management
- Create subscription plans in Stripe
- Implement subscription workflows:
  - Initial subscription
  - Renewal process
  - Cancellation handling
- Design and implement subscription dashboard

#### 2.4 Streamer Dashboard
- Create main dashboard UI
- Implement analytics views
- Build settings management interface
- Add channel-specific customization options

#### 2.5 Admin Functions
- Create admin panel for service management
- Implement user support interface
- Add monitoring and reporting tools

### 3. Backend Services Development

#### 3.1 Shared API Server
- Set up Cloudflare Workers for API endpoints
- Implement authentication and authorization
- Create shared data models
- Configure security measures using Cloudflare's built-in protections

#### 3.2 Riot API Proxy
- Create Cloudflare Worker to:
  - Protect Riot API key and client credentials
  - Handle rate limiting using Cloudflare's built-in features
  - Cache common requests in Cloudflare KV
- Implement efficient data storage strategy with Cloudflare D1
- Set up secure OAuth proxy for Riot RSO

#### 3.3 Subscription Verification API
- Create fast Cloudflare Worker endpoint for subscription checks
- Implement multi-level caching strategy with Cloudflare KV
- Design efficient database queries for Cloudflare D1

#### 3.4 Database Setup
- Configure Cloudflare D1 with appropriate schemas
- Implement data validation
- Set up backup and recovery procedures
- Utilize Cloudflare's built-in security features

### 4. Integration and Testing

#### 4.1 Extension Testing
- Unit tests for core functionality
- End-to-end testing on actual Twitch pages
- Cross-browser compatibility testing
- Performance optimization

#### 4.2 Web App Testing
- Component tests for React elements
- Integration tests for API endpoints
- User flow testing
- Payment system testing

#### 4.3 Security Testing
- Penetration testing for web app
- Data security audit
- API endpoint security review

### 5. Deployment

#### 5.1 Extension Deployment
- Set up CI/CD pipeline with GitHub Actions
- Publish to Chrome Web Store
- Implement monitoring system using Cloudflare Analytics

#### 5.2 Web Application Deployment
- Configure Cloudflare Pages for production environment
- Utilize automatic SSL certificates from Cloudflare
- Set up custom domain with Cloudflare DNS
- Configure monitoring and alerting through Cloudflare Dashboard

#### 5.3 Backend Deployment
- Deploy Workers to Cloudflare's global network
- Configure Cloudflare D1 for production environment
- Set up logging and monitoring through Cloudflare Dashboard

### 6. Post-Launch
- Monitor for Twitch interface changes
- Collect user feedback
- Plan for feature expansion
- Explore Firefox and Edge compatibility

## Technical Implementation Details

### Extension-Backend Communication
```javascript
// Example of extension checking subscription status
const checkChannelSubscription = async (channelName) => {
  // Check local cache first
  if (subscribedChannels.has(channelName)) return true;
  
  // Check memory cache with timestamp
  const cached = subscriptionCache.get(channelName);
  if (cached && (Date.now() - cached.timestamp < CACHE_DURATION)) {
    if (cached.status) subscribedChannels.add(channelName);
    return cached.status;
  }
  
  // Call API to check subscription
  try {
    const response = await fetch(`${API_URL}/api/subscription/verify?channel=${channelName}`);
    const data = await response.json();
    
    // Update cache
    subscriptionCache.set(channelName, {
      timestamp: Date.now(),
      status: data.subscribed
    });
    
    if (data.subscribed) {
      subscribedChannels.add(channelName);
    }
    
    return data.subscribed;
  } catch (error) {
    console.error('Failed to verify subscription:', error);
    return false;
  }
};
```

### Content Script Injection
```javascript
// Example based on 7TV/BetterTTV approach
const injectBadges = () => {
  // Get current channel name
  const channelName = getCurrentChannel();
  
  // Check if channel is subscribed
  checkChannelSubscription(channelName).then(isSubscribed => {
    if (!isSubscribed) return; // Don't proceed if channel isn't subscribed
    
    // Select chat messages
    const chatMessages = document.querySelectorAll('.chat-line__message');
    
    // Process each message
    chatMessages.forEach(message => {
      const username = message.querySelector('.chat-author__display-name').textContent;
      fetchAndDisplayBadge(username, message);
    });
  });
};

// Set up MutationObserver for new messages
const chatObserver = new MutationObserver(mutations => {
  // Get current channel name
  const channelName = getCurrentChannel();
  
  // Only proceed if we've verified this channel is subscribed
  if (!subscribedChannels.has(channelName)) return;
  
  mutations.forEach(mutation => {
    mutation.addedNodes.forEach(node => {
      if (node.classList && node.classList.contains('chat-line__message')) {
        // Process new chat message
        const username = node.querySelector('.chat-author__display-name').textContent;
        fetchAndDisplayBadge(username, node);
      }
    });
  });
});

// Only start observation if channel is subscribed
checkChannelSubscription(getCurrentChannel()).then(isSubscribed => {
  if (isSubscribed) {
    chatObserver.observe(document.querySelector('.chat-scrollable-area__message-container'), {
      childList: true
    });
  }
});
```

### Web App API Endpoints
```javascript
// Example API endpoints for the web application

// User authentication
app.post('/api/auth/twitch', async (req, res) => {
  // Handle Twitch OAuth authentication
});

// Subscription management
app.post('/api/subscriptions/create', requireAuth, async (req, res) => {
  // Create a new subscription using Stripe
});

app.get('/api/subscriptions/status', requireAuth, async (req, res) => {
  // Get current subscription status
});

// Subscription verification endpoint (called by extension)
app.get('/api/subscription/verify', async (req, res) => {
  const { channel } = req.query;
  
  if (!channel) {
    return res.status(400).json({ error: 'Channel name required' });
  }
  
  try {
    // Check if channel has an active subscription
    const subscription = await Subscription.findOne({
      channelName: channel.toLowerCase(),
      status: 'active'
    });
    
    return res.json({
      subscribed: !!subscription
    });
  } catch (error) {
    console.error('Subscription verification error:', error);
    return res.status(500).json({ error: 'Server error' });
  }
});
```

### Riot RSO Proxy Endpoints
```javascript
// Example API endpoints for the Riot RSO proxy

// Initialize authentication flow
app.post('/auth/riot/init', async (req, res) => {
  const { region, state, redirectUri } = req.body;
  
  if (!region || !state || !redirectUri) {
    return res.status(400).json({ error: 'Missing required parameters' });
  }
  
  try {
    // Construct the authorization URL with our client ID (stored securely on the server)
    const params = new URLSearchParams({
      client_id: process.env.RIOT_CLIENT_ID,
      redirect_uri: redirectUri,
      response_type: 'code',
      scope: 'openid offline_access lol-account',
      state: state
    });
    
    const authUrl = `https://auth.riotgames.com/authorize?${params.toString()}`;
    
    return res.json({ authUrl });
  } catch (error) {
    console.error('Auth initialization error:', error);
    return res.status(500).json({ error: 'Server error' });
  }
});

// Exchange code for token
app.post('/auth/riot/token', async (req, res) => {
  const { code, redirectUri } = req.body;
  
  if (!code || !redirectUri) {
    return res.status(400).json({ error: 'Missing required parameters' });
  }
  
  try {
    // Exchange the code for a token using our client credentials
    const tokenResponse = await fetch('https://auth.riotgames.com/token', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: new URLSearchParams({
        grant_type: 'authorization_code',
        code: code,
        redirect_uri: redirectUri,
        client_id: process.env.RIOT_CLIENT_ID,
        client_secret: process.env.RIOT_CLIENT_SECRET
      }).toString()
    });
    
    if (!tokenResponse.ok) {
      throw new Error(`Token exchange failed: ${tokenResponse.status}`);
    }
    
    const tokenData = await tokenResponse.json();
    
    return res.json(tokenData);
  } catch (error) {
    console.error('Token exchange error:', error);
    return res.status(500).json({ error: 'Server error' });
  }
});

// Refresh token
app.post('/auth/riot/token/refresh', async (req, res) => {
  const { refreshToken } = req.body;
  
  if (!refreshToken) {
    return res.status(400).json({ error: 'Missing refresh token' });
  }
  
  try {
    // Refresh the token using our client credentials
    const tokenResponse = await fetch('https://auth.riotgames.com/token', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: refreshToken,
        client_id: process.env.RIOT_CLIENT_ID,
        client_secret: process.env.RIOT_CLIENT_SECRET
      }).toString()
    });
    
    if (!tokenResponse.ok) {
      throw new Error(`Token refresh failed: ${tokenResponse.status}`);
    }
    
    const tokenData = await tokenResponse.json();
    
    return res.json(tokenData);
  } catch (error) {
    console.error('Token refresh error:', error);
    return res.status(500).json({ error: 'Server error' });
  }
});

// Proxy for Riot API requests
app.get('/riot/account/me', async (req, res) => {
  const { region } = req.query;
  const authHeader = req.headers.authorization;
  
  if (!region || !authHeader) {
    return res.status(400).json({ error: 'Missing required parameters' });
  }
  
  try {
    const response = await fetch(`https://${region}.api.riotgames.com/riot/account/v1/accounts/me`, {
      headers: {
        'Authorization': authHeader
      }
    });
    
    if (!response.ok) {
      throw new Error(`Account request failed: ${response.status}`);
    }
    
    const data = await response.json();
    
    return res.json(data);
  } catch (error) {
    console.error('Account request error:', error);
    return res.status(500).json({ error: 'Server error' });
  }
});
```

## Technical Challenges and Solutions

### Securing Riot Client Credentials
- **Challenge**: Protecting Riot client ID and secret
- **Solution**: Backend proxy server to handle OAuth flow
- **Implementation**: All sensitive credentials stored server-side only

### Twitch DOM Integration
- **Challenge**: Reliably identifying and modifying chat elements
- **Solution**: Study 7TV/BetterTTV implementations for best practices
- **Implementation**: Use MutationObserver and targeted DOM operations

### User Identity Management
- **Challenge**: Reliably identifying Twitch users without login
- **Solution**: Multiple extraction methods from DOM elements
- **Implementation**: Pattern matching similar to 7TV/BetterTTV

### Streamer Identity Tracking
- **Challenge**: Channel name changes breaking subscription tracking
- **Solution**: Store both Twitch username and unique Twitch ID
- **Implementation**: Use Twitch ID as primary key in database

### Rate Limiting
- **Challenge**: Riot API has strict rate limits
- **Solution**: Implement intelligent caching on both client and server
- **Implementation**: Prioritize active users, use appropriate cache TTLs

### Subscription Verification
- **Challenge**: Efficiently verifying if a channel is subscribed
- **Solution**: Multi-level caching strategy
- **Implementation**: Browser cache, memory cache, database lookups in sequence

### Extension-Web App Communication
- **Challenge**: Secure and efficient communication between components
- **Solution**: RESTful API with appropriate authentication
- **Implementation**: JWT or API key authentication for secure endpoints

### Performance
- **Challenge**: Minimizing impact on Twitch experience
- **Solution**: Efficient DOM operations and background processing
- **Implementation**: Lazy loading, progressive enhancement

### Security
- **Challenge**: Protecting API keys and user data
- **Solution**: Minimize data collection, use secure storage
- **Implementation**: Proxy sensitive API calls through backend

## Cloudflare Implementation Strategy

### Primary Approach: Full Cloudflare Stack
- **Implementation**:
  - Use Cloudflare Workers for all API endpoints and backend services
  - Use Cloudflare Pages for the streamer web application frontend
  - Use Cloudflare D1 (SQLite database) for all data storage needs
  - Implement Cloudflare KV for caching and state management
  - Utilize Cloudflare Durable Objects for coordination when needed
- **Benefits**:
  - Leverages existing Cloudflare subscription for cost efficiency
  - Global distribution for optimal performance worldwide
  - Simplified deployment and management through a single platform
  - Strong security features built into the platform
  - Seamless scaling without infrastructure management
  - Reduced operational complexity with unified monitoring and logging

### Implementation Details

#### Cloudflare Workers
- Implement all API endpoints as Workers
- Use Workers for authentication proxy and Riot API integration
- Utilize Workers for subscription verification
- Take advantage of built-in security headers and protection

#### Cloudflare Pages
- Host the React frontend application
- Use Pages Functions for server-side operations
- Implement automatic deployments from GitHub
- Utilize built-in analytics and performance monitoring

#### Cloudflare D1
- Store all structured data including:
  - Streamer accounts and subscription information
  - User preferences and settings
  - Analytics data
- Implement efficient query patterns for optimal performance

#### Cloudflare KV
- Cache frequently accessed data:
  - Subscription status for popular channels
  - Riot API responses
  - Authentication tokens
- Implement tiered caching strategy for optimal performance

#### Cloudflare Durable Objects
- Use for coordination when needed:
  - Rate limit tracking
  - Global state management
  - Concurrent operation handling

## Future Expansion Possibilities
- Support for additional games (Valorant, CS:GO, etc.)
- Custom badge designs for premium subscribers
- Streamer-specific badge variations
- Integration with stream overlays
- Special badges for channel moderators or subscribers
